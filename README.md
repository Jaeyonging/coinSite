# 🪙 김치프리미엄 체크 사이트

업비트와 바이낸스 간의 암호화폐 가격 차이를 실시간으로 확인할 수 있는 웹사이트다.

🌐 **배포 사이트**: [https://coin-site-tau.vercel.app/](https://coin-site-tau.vercel.app/)

---

## 프로젝트 소개

암호화폐 거래를 하면서 "지금 김치프리미엄이 얼마나 되지?"라는 궁금증이 생겼다. 매번 업비트와 바이낸스를 번갈아가며 확인하는 게 번거로워서, 한 화면에서 실시간으로 비교할 수 있는 사이트를 만들기로 했다.

처음엔 가격만 보여주면 될 줄 알았는데, 막상 만들다 보니 정렬, 검색, 그래프, 즐겨찾기 등 생각보다 많은 기능이 필요했다. 그 과정에서 많은 걸 배웠다.

---

## 주요 기능

- **실시간 가격 업데이트**: 업비트/바이낸스 WebSocket으로 체결가를 받아와 테이블에 즉시 반영 (`requestAnimationFrame`으로 배치 처리하여 성능 최적화)
- **김치프리미엄 계산**: 해외 USDT 시세 × 환율과 국내 가격을 비교해 퍼센트로 표시
- **캔들스틱 차트**: 
  - SVG 기반 캔들 차트, 모바일에서도 툴팁/크로스헤어 사용 가능
  - 시간 단위 선택 (1분, 5분, 15분, 30분, 1시간, 1일, 15일, 30일)
  - 실시간 체결가가 들어오면 마지막 캔들을 바로 갱신해 차트/테이블 가격이 어긋나지 않음
  - 모의 투자 포지션이 있을 경우 차트에 매수 가격 마커 표시
  - 모바일 터치 제스처 지원 및 스크롤 동기화
- **모의 투자 시스템**:
  - **대시보드**: 총 자산, 잔고, 투자금, 손익, 수익률 요약 표시
  - **포지션 관리**: 매수/매도, 평균 단가 자동 계산, 손익 실시간 추적
  - **트레이딩 패널**: 테이블 행을 클릭하면 하단 바텀시트가 열려 1분 차트, 잔고, 수익률, 매수/매도 폼과 MAX 버튼(8자리 반올림)을 제공
  - **입금 기능**: 가상 잔고에 추가 입금 가능
  - **초기화 기능**: 모든 포지션과 잔고를 초기 상태로 리셋
  - 데이터는 로컬 스토리지에 저장되어 새로고침해도 유지됨
- **즐겨찾기 & 검색/정렬**: 
  - 쿠키 기반 즐겨찾기 저장 (1년 만료)
  - 한/영 이름 검색 및 즐겨찾기 자동 상단 고정
  - 가격, 김치프리미엄, 전일가, 절대 변동액, 변동률, 24시간 거래대금 등 7가지 정렬 키를 오름/내림/기본 순으로 토글
- **반응형 테이블**: Tailwind CSS로 데스크톱/모바일 양쪽에서 컬럼이 깔끔히 정렬되도록 구성

---

## 실시간 데이터 파이프라인

1. **마켓 초기화** (`useMarketInitialization`)  
   업비트 `/v1/market/all`을 한 번 호출해 KRW 마켓만 필터링하고, `upbitCoins` 맵과 `coinNames` 배열, 기본 USDT 심볼셋을 Redux에 채워 넣는다.
2. **초기 시세 로딩** (`useInitialPriceFetch`)  
   초기화된 마켓 코드를 콤마로 합쳐 업비트 `/v1/ticker`를 호출하고, `coinKrwPriceSlice`에 첫 화면을 그릴 수 있는 가격/하락률/거래대금 정보를 저장한다.
3. **실시간 스트림** (`useRealtimePriceStreams`)  
   - 업비트 WebSocket: Blob을 `text()`로 파싱해 체결가, 전일 종가, 등락률을 받고 `syncKRWPrice2`로 Redux를 업데이트한다.  
   - 바이낸스 선물 WebSocket: `fstream.binance.com`의 `@markPrice@1s` 스트림을 여러 코인으로 묶어 구독하고, `syncUSPRICE`로 해외 시세를 갱신한다.  
   - 두 스트림 모두 `requestAnimationFrame` 안에서 배치 처리해 초당 수십 건의 dispatch가 발생해도 프레임이 끊기지 않는다.
4. **환율 동기화** (`useExchangeRate`)  
   Google Spreadsheet CSV에서 KRW/USD를 읽어오고, 실패 시 1,389원을 즉시 대체 값으로 사용한다. 헤더와 김치프리미엄 계산에서 동일한 환율을 공유한다.
5. **차트 데이터** (`useCoinChartData`)  
   선택한 시간 단위에 맞춰 업비트 캔들을 REST로 가져오고, 실시간 체결가가 들어오면 마지막 캔들을 직접 업데이트한다. 덕분에 `ChartPurchaseMarker`와 모의 투자 패널의 1분 차트도 테이블과 완전히 일치한다.

---

## 정렬/필터 규칙

- 즐겨찾기는 `coin_favorites` 쿠키에 저장되고 리스트의 맨 위에 항상 고정된다.
- 검색창은 한글/영문 이름을 모두 소문자로 변환해 부분 일치 검색을 수행한다.
- 정렬 버튼을 누를 때마다 `오름차순 → 내림차순 → 기본`으로 순환하며, 기본 상태에서는 KRW 가격 내림차순으로 정렬된다.

| 정렬 키 | 설명 |
| --- | --- |
| `koreanName` | 한글 이름 기준 사전순 |
| `price` | 업비트 KRW 현재가 |
| `kimp` | `(국내가 - (해외 USDT × 환율)) / (해외 USDT × 환율)` 로 계산한 김치프리미엄 |
| `prevPrice` | 업비트 전일 종가 |
| `absValue` | 전일 대비 절대 변동 금액 (`change_price` 값을 등락 방향에 맞춰 부호 적용) |
| `changePercent` | 등락률 (`change_rate × 100` 값을 방향에 따라 ± 표시) |
| `accTradePrice24h` | 업비트 24시간 누적 거래대금 |

---

## 모의 투자 흐름

- `useMockTradingState`가 `mockTrading_balance`/`mockTrading_positions` 키를 로컬 스토리지에서 읽어 초기 잔고(1천만 원)와 포지션 배열을 구성하고, 변경 사항은 `storage` 및 커스텀 `mockTradingUpdate` 이벤트로 다른 탭과도 동기화된다.
- `MockTradingDashboard`의 `AssetSummary`는 `utils/mockTrading`의 집계 함수로 총자산·투자금·손익·수익률을 계산하고, 입금(`DepositModal`)과 전체 리셋(`ResetModal`)을 제공한다.
- `PositionsTable`은 보유 포지션을 테이블로 보여주며, 한 행을 클릭하면 `MockTradingPanel` 바텀시트가 열려 해당 코인에 집중할 수 있다.
- 바텀시트에는 1분 차트(매수 포지션이 있으면 `ChartPurchaseMarker`로 평단 표시), `PanelBalanceSummary`, `BuyTradeForm`, `SellTradeForm`, 잔여 수량/최대 매수 계산 등이 포함돼 있다.
- 매수 시 `applyBuyToPositions`가 `(기존 총액 + 신규 총액) / 총 수량` 방식으로 평균 단가를 재계산하고, 매도 시 `applySellToPositions`가 수량을 차감하며 `calculateSellProfit`으로 손익을 계산한다. 모든 수량은 8자리까지 반올림해 거래한다.
- 모든 변경 사항은 즉시 저장되므로 페이지를 새로고침해도 포지션과 잔고, 매수 날짜가 유지된다.

---

## 기술 스택

- **React 18 + TypeScript**: 타입 안정성과 컴포넌트 단위 개발
- **Vite**: 번개 같은 HMR과 번들링
- **Redux Toolkit + React Redux**: 실시간 가격/환율 상태 중앙 집중 관리
- **React Router DOM**: 라우팅 관리
- **Tailwind CSS**: 테이블·차트·패널을 유연하게 스타일링
- **Axios & WebSocket**: REST 호출과 실시간 시세 스트림
- **React GA4**: 사용자 행동 분석
- **React Icons**: 아이콘 라이브러리
- **Vercel**: 배포 플랫폼 (API 프록시 설정 포함)

---

## 프로젝트 구조

```
src/
├── api/
│   ├── services/          # 환율·업비트 등 외부 API 호출
│   └── types/             # API 응답 타입 정의
├── components/
│   ├── chart/             # SVG 차트와 관련 UI
│   ├── coinTable/         # 시세 테이블과 셀 컴포넌트
│   ├── coinList/          # 검색/필터 등 리스트 UI
│   ├── mockTrading/       # 모의 투자 대시보드 & 패널
│   └── layout/            # 헤더·푸터 등 공용 레이아웃
├── hooks/
│   ├── coinList/          # 리스트 관련 상태 훅
│   └── mockTrading/       # 모의 투자 상태 훅
├── store/                 # Redux slice와 스토어 설정
├── styles/                # Tailwind 진입점(global.css)
├── types/                 # 도메인 전역 타입
├── utils/                 # 포매터, 계산 로직
└── pages/                 # 최상위 페이지
```

컴포넌트를 역할별로 쪼개면서 차트, 테이블, 모의 투자 UI를 독립적으로 다룰 수 있어 유지보수가 쉬워졌다.

---

## 개발하면서 배운 점

### WebSocket 메시지 처리와 성능 최적화

업비트 WebSocket이 Blob 형식으로 데이터를 보내주는데, 처음엔 `FileReader`를 썼다. 그런데 코드가 복잡해지고, `Blob.text()`가 더 간단하다는 걸 나중에 알았다. 작은 것들이지만 이런 걸 알게 되는 게 재밌다.

진짜 문제는 메시지가 너무 빨리 와서 Redux dispatch가 과도하게 발생하는 거였다. 화면이 버벅거리기 시작했고, 개발자 도구를 보니 초당 수십 번씩 dispatch가 일어나고 있었다. 이걸 해결하려고 `requestAnimationFrame`으로 배치 처리하니 훨씬 부드러워졌다. 

실시간 데이터를 다룰 때는 이런 최적화가 정말 중요하다는 걸 느꼈다. 단순히 데이터를 받아서 상태에 넣는 게 아니라, 언제 어떻게 업데이트할지도 고민해야 한다.

### React 성능 최적화의 중요성

가격이 업데이트될 때마다 전체 테이블이 리렌더링되면서 화면이 버벅거렸다. 처음엔 뭐가 문제인지도 모르겠고, 그냥 "React가 느린가?" 싶었다. 

`React.memo`로 컴포넌트를 감싸고, `useMemo`와 `useCallback`을 적절히 사용하니 확실히 나아졌다. Redux store 설정에서 `immutableCheck: false`로 설정하는 것도 도움이 됐다. 

이 과정에서 배운 건, 성능 문제는 보통 한 곳에 있는 게 아니라 여러 곳에서 조금씩 누적되는 거라는 거다. 하나씩 최적화해나가면서 점점 부드러워지는 걸 보는 게 뿌듯했다.

### 모바일 반응형의 어려움

모바일에서 테이블을 보여주는 게 생각보다 어려웠다. 처음엔 카드 형식으로 만들었는데, 사용자가 테이블 형식을 원해서 다시 바꿨다. 

폰트 크기를 줄이고, 패딩을 최소화하고, 컬럼 너비를 조정해도 가로 스크롤이 생겼다. `table-layout: fixed`를 쓰고 각 컬럼에 명시적으로 너비를 지정하니 해결됐다. 

모바일에서는 정말 픽셀 단위로 신경 써야 한다는 걸 느꼈다. 데스크톱에서는 문제없던 게 모바일에서는 완전히 깨졌었다. 미디어 쿼리로 하나하나 조정하는 게 번거로웠지만, 결과를 보니 그럴 만했다.

### Redux와 로컬 상태의 균형

Redux를 처음 써봤는데, 처음엔 모든 상태를 Redux에 넣으려고 했다. 검색어도, 정렬 설정도, 차트 열림 상태도 전부. 그런데 이게 오히려 복잡해졌다.

나중에 깨달은 건, 정말 전역으로 공유해야 하는 상태(가격 데이터, 코인 목록)만 Redux에 넣고, 나머지는 `useState`로 관리하는 게 훨씬 간단하다는 거다. 

Redux Toolkit의 `createSlice`가 정말 편했다. 기존 Redux처럼 액션 타입, 액션 크리에이터, 리듀서를 각각 작성할 필요 없이 한 곳에서 정의할 수 있어서 코드가 훨씬 간결해졌다. `immer`가 내장되어 있어서 불변성 신경 안 써도 되는 것도 좋았다.

### TypeScript 타입 가드의 유용성

WebSocket 메시지 같은 동적 데이터를 다룰 때 타입 가드가 정말 유용했다. `if (parsed.data && parsed.data.s && parsed.data.p)` 같은 체크를 타입으로 보장할 수 있어서, 그 이후 코드에서는 안전하게 속성에 접근할 수 있었다.

처음엔 타입 정의하는 게 번거로웠지만, 나중에 API가 변경됐을 때 에디터에서 바로 에러를 잡아주니까 디버깅 시간이 확실히 줄었다. 런타임 에러보다 컴파일 타임 에러가 훨씬 찾기 쉽다.

### 컴포넌트 분리의 중요성

처음엔 큰 컴포넌트 하나에 모든 걸 때려넣었다. 그런데 나중에 수정하려고 보니 어디가 뭘 하는지 찾기 어려웠다. 

작은 컴포넌트로 분리하면서 재사용성과 가독성이 훨씬 좋아졌다. 특히 테이블 셀들을 각각 컴포넌트로 분리한 게 좋은 선택이었다. 나중에 스타일을 바꾸거나 기능을 추가할 때도 해당 컴포넌트만 수정하면 돼서 편했다.

### Tailwind로 테이블과 차트 정리하기

예전에는 Bootstrap 컴포넌트에 스타일을 덧대서 쓰다 보니 세부 간격이나 반응형 처리가 마음대로 되지 않았다. Tailwind로 갈아타고 나서는 클래스 하나하나 손으로 정리해야 해서 귀찮긴 했지만, 컬럼 폭이나 모바일 패딩을 픽셀 단위로 맞출 수 있어서 훨씬 깔끔해졌다. 특히 캔들 차트가 테이블보다 왼쪽으로 치우치던 문제를 잡으면서 "디자인 시스템을 직접 쥐고 있는 게 이런 느낌이구나" 싶었다.

### 모의 투자 패널을 만들며

실시간 시세만 보여주는 게 아쉬워서 모의 투자 탭을 붙였는데, 생각보다 고려할 게 많았다. 잔고 업데이트, 포지션 평균 단가 계산, 매수/매도 폼 유효성 검사까지 다 직접 만들어야 했다. 

특히 평균 단가 계산 로직을 구현할 때, 기존 포지션이 있을 때와 없을 때를 구분해서 처리해야 했다. 매수할 때마다 `(기존 총액 + 신규 총액) / 총 수량`으로 평균 단가를 다시 계산하는 로직을 직접 구현했다.

로컬 스토리지에 데이터를 저장해서 새로고침해도 포지션이 유지되도록 했고, 여러 탭에서 동기화되도록 `storage` 이벤트 리스너도 추가했다. 

차트에 매수 가격을 마커로 표시하는 기능도 추가했는데, 매수 날짜와 캔들 데이터를 매칭하는 게 생각보다 까다로웠다. 날짜 형식이 다르거나 해당 날짜의 캔들이 없을 경우를 처리해야 했다.

그래도 하나씩 구현하면서 진짜 트레이딩 앱을 만드는 기분이 나서 재밌었다. 사용자 입장에서 어떤 흐름이 자연스러운지도 계속 고민하게 돼서 UX 감각도 조금은 좋아진 것 같다.

---

## 어려웠던 점

### 바이낸스 WebSocket 데이터 파싱

바이낸스는 스트림 형식으로 여러 코인을 한 번에 보내주는데, 데이터 구조가 복잡했다. `{ data: { s: "BTCUSDT", p: "50000" } }` 형식으로 파싱해야 했고, 특히 심볼을 `BTCUSDT` → `BTC`로 변환하고 대문자로 만드는 걸 깜빡해서 한참 디버깅했다. 가격이 업데이트가 안 되는 줄 알고 WebSocket 연결 문제인 줄 알았는데, 알고 보니 심볼 매칭이 안 돼서였다. 

이런 작은 실수 하나가 몇 시간을 날릴 수 있다는 걸 뼈저리게 느꼈다. 디버깅할 때는 항상 데이터를 콘솔에 찍어보는 게 중요하다.

### 실시간 업데이트 성능 문제

가격이 업데이트될 때마다 애니메이션이 실행되면서 성능이 저하됐다. 처음엔 배경색 애니메이션을 썼는데, 이게 너무 무거웠다. 텍스트 색상 애니메이션으로 바꿨는데도 부드럽지 않았다.

`requestAnimationFrame`으로 배치 처리하니 훨씬 나아졌다. 하지만 여전히 완벽하지는 않다. 실시간으로 수십 개의 가격이 동시에 업데이트되면 어느 정도 버벅거림은 피할 수 없는 것 같다.

이 과정에서 배운 건, 애니메이션은 신중하게 써야 한다는 거다. 모든 걸 애니메이션으로 만들면 오히려 사용자 경험이 나빠질 수 있다.

### 모바일 레이아웃의 한계

모바일에서 테이블을 보여주면서도 가로 스크롤 없이 모든 정보를 보여주는 게 어려웠다. 폰트 크기를 줄이고, 패딩을 최소화하고, 컬럼 너비를 조정해도 여전히 공간이 부족했다.

결국 일부 컬럼을 숨기거나, 폰트 크기를 더 줄이거나, 레이아웃을 바꿔야 했다. 완벽한 해결책은 없었고, 타협점을 찾는 게 중요했다.

모바일에서는 정말 제약이 많다는 걸 느꼈다. 데스크톱에서는 당연하게 보여줄 수 있는 정보도 모바일에서는 포기해야 할 때가 있다.

### SVG 차트 구현의 복잡함

SVG로 캔들스틱 차트를 직접 그리는 게 생각보다 복잡했다. 가격 범위 계산, Y축 좌표 변환, 시간 단위별 라벨 표시 등 고려할 게 많았다.

특히 스크롤을 고려한 툴팁 위치 계산이 까다로웠다. 처음엔 단순히 마우스 위치에 툴팁을 띄웠는데, 스크롤하면 위치가 어긋났다. `getBoundingClientRect()`를 써서 정확한 위치를 계산하니 해결됐다.

모바일에서 터치 이벤트를 처리하는 것도 까다로웠다. 차트를 터치할 때 테이블이 스크롤되는 걸 방지하기 위해 `stopPropagation()`을 사용했고, 모바일과 데스크톱에서 Y축을 다르게 표시해야 했다. 모바일에서는 별도의 Y축 컴포넌트를 만들어서 차트 왼쪽에 고정시켰다.

시간 단위를 변경할 때마다 차트가 맨 오른쪽(최신 데이터)으로 자동 스크롤되도록 했는데, 이게 생각보다 까다로웠다. `setTimeout`을 써서 렌더링이 완료된 후에 스크롤하도록 해야 했다.

라이브러리를 쓰면 이런 걸 다 해결해주지만, 직접 구현하면서 더 세밀하게 커스터마이징할 수 있어서 좋았다. 다만 시간이 많이 걸렸다.

---

## 앞으로 개선하고 싶은 점

1. **차트 기능 강화** - 이동평균선이나 볼린저 밴드 같은 기술적 지표 추가
2. **알림 기능** - 특정 김치프리미엄 수준에 도달하면 알림
3. **히스토리 데이터** - 과거 김치프리미엄 추이를 그래프로 표시
4. **다른 거래소 추가** - 바이낸스 말고 다른 거래소도 비교
5. **성능 최적화** - 가상화(virtualization) 적용해서 더 많은 코인 부드럽게 표시

---

## 설치 및 실행

```bash
# 의존성 설치
npm install

# 개발 서버 실행 (포트 3000)
npm run dev

# 빌드
npm run build

# 빌드 결과 미리보기
npm run preview
```

### 개발 환경 설정

환경 변수는 `.env` 파일에 설정하면 된다 (선택사항):
```
VITE_GA_PROPERTYID=your_ga_id
```

> 참고: 환경 변수가 없어도 앱은 정상 작동하지만, Google Analytics 추적 기능만 비활성화됩니다.

### Vite 프록시 설정

개발 환경에서 업비트 API를 사용하기 위해 `vite.config.ts`에 프록시 설정이 포함되어 있습니다:
- `/api/*` → `https://api.upbit.com/*`
- `/wss/*` → `wss://api.upbit.com/*` (WebSocket)

프로덕션 환경에서는 Vercel의 `vercel.json` 설정을 통해 API 프록시가 처리됩니다.

---

## 데이터 출처 & 저장 방식

### 외부 데이터 소스

- **업비트 REST API**: `/v1/market/all`, `/v1/ticker`, `/v1/candles/*`를 Vite/Vercel 프록시로 호출해 마켓·현재가·캔들 데이터를 가져온다.
- **업비트 WebSocket**: `wss://api.upbit.com/websocket/v1`의 `ticker` 스트림으로 실시간 체결가, 등락률, 24시간 거래대금을 수신한다.
- **바이낸스 Futures WebSocket**: `wss://fstream.binance.com/stream?streams={symbol}@markPrice@1s`로 해외 USDT 기준가를 가져온다.
- **환율 데이터**: Google Spreadsheet CSV를 직접 읽어오고(실패 시 1,389원으로 폴백), 헤더와 김치프리미엄 계산에 재사용한다.

### 클라이언트 저장

- **즐겨찾기**: 쿠키에 저장 (1년 만료, `coin_favorites` 키 사용)
- **모의 투자 데이터**: 로컬 스토리지에 저장
  - 잔고: `mockTrading_balance` 키
  - 포지션: `mockTrading_positions` 키 (JSON 형식)
  - 기본 잔고: 10,000,000원
  - 여러 탭 간 동기화 지원 (`storage` + 커스텀 `mockTradingUpdate` 이벤트)

## 배포

- **플랫폼**: Vercel
- **API 프록시**: `vercel.json`을 통해 업비트 API 프록시 설정
- **빌드**: Vite 빌드 결과물을 Vercel에 배포
- **환경 변수**: Vercel 대시보드에서 `VITE_GA_PROPERTYID` 설정

## 후기

처음엔 단순히 가격만 보여주면 될 줄 알았는데, 막상 만들다 보니 생각보다 많은 기능이 필요했다. WebSocket을 다루고, 성능 최적화를 하고, 모바일 반응형을 구현하면서 실무에 가까운 경험을 할 수 있었다.

특히 모의 투자 기능을 추가하면서 단순히 데이터를 보여주는 것을 넘어서 사용자가 직접 상호작용할 수 있는 기능을 만드는 게 얼마나 복잡한지 알게 됐다. 평균 단가 계산, 손익 추적, 차트에 매수 마커 표시 등 하나하나 구현하면서 많은 걸 배웠다.

아직 부족한 점이 많지만, 계속 개선해나가면서 더 나은 서비스로 만들어가고 싶다.

## 느낀 점

개발 초반에는 "이 정도면 됐겠지" 싶다가도 직접 써보면 항상 아쉬운 부분이 튀어나왔다. 차트 패딩이 어색하면 그 작은 디테일 때문에 전체 완성도가 떨어져 보이고, 테이블이 살짝만 어긋나도 신뢰도가 확 줄어든다. 그래서 결국은 디테일을 다듬는 시간이 프로젝트의 절반 이상이라는 걸 몸소 느꼈다. 그래도 그런 시행착오 덕분에 내가 원하는 퀄리티가 어떤 건지 조금씩 감이 잡히는 것 같다.
