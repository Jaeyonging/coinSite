# 🪙 김치프리미엄 체크 사이트

업비트와 바이낸스 간의 암호화폐 가격 차이를 실시간으로 확인할 수 있는 웹사이트입니다.

🌐 **배포 사이트**: [https://coin.jaeyonging.com/](https://coin.jaeyonging.com/)

---

## 프로젝트 소개

암호화폐 거래를 하면서 "지금 김치프리미엄이 얼마나 되지?"라는 궁금증이 생겼습니다. 매번 업비트와 바이낸스를 번갈아가며 확인하는 게 번거로워서, 한 화면에서 실시간으로 비교할 수 있는 사이트를 만들기로 했습니다.

처음엔 가격만 보여주면 될 줄 알았는데, 막상 만들다 보니 정렬, 검색, 차트, 즐겨찾기, 모의 투자, 채팅 등 생각보다 많은 기능이 필요했습니다. 그 과정에서 많은 걸 배웠습니다.

---

## 주요 기능

### 실시간 가격 업데이트
- 업비트/바이낸스 WebSocket으로 체결가를 받아와 테이블에 즉시 반영
- `requestAnimationFrame`으로 배치 처리하여 성능 최적화
- 가격 변동 시 색상 애니메이션으로 시각적 피드백 제공

### 김치프리미엄 계산
- 해외 USDT 시세 × 환율과 국내 가격을 비교해 퍼센트로 표시
- 실시간으로 업데이트되는 김치프리미엄으로 차익거래 기회 파악

### TradingView 차트
- TradingView 위젯을 활용한 전문적인 차트 제공
- 바이낸스에 상장된 코인은 바이낸스 차트, 그 외는 업비트 차트 자동 표시
- 테이블에서 각 코인별로 차트 토글 가능
- 모의 투자 패널에서도 TradingView 차트 제공
- 다크 모드 지원

### 모의 투자 시스템
- **대시보드**: 총 자산, 잔고, 투자금, 손익, 수익률 요약 표시
- **포지션 관리**: 매수/매도, 평균 단가 자동 계산, 손익 실시간 추적
- **트레이딩 패널**: 테이블 행을 클릭하면 하단 바텀시트가 열려 TradingView 차트, 잔고, 수익률, 매수/매도 폼과 MAX 버튼(8자리 반올림)을 제공
- **입금 기능**: 가상 잔고에 추가 입금 가능
- **초기화 기능**: 모든 포지션과 잔고를 초기 상태로 리셋
- 데이터는 로컬 스토리지에 저장되어 새로고침해도 유지됨

### 실시간 채팅
- Socket.IO 기반 실시간 채팅 기능
- 사용자 수 실시간 표시
- 랜덤 닉네임 자동 생성 및 로컬 스토리지 저장
- 새 메시지 알림 기능
- 모바일 반응형 지원

### 즐겨찾기 & 검색/정렬
- 쿠키 기반 즐겨찾기 저장 (1년 만료)
- 한/영 이름 검색 및 즐겨찾기 자동 상단 고정
- 가격, 김치프리미엄, 전일가, 절대 변동액, 변동률, 24시간 거래대금 등 7가지 정렬 키를 오름/내림/기본 순으로 토글

### 반응형 디자인
- Tailwind CSS로 데스크톱/모바일 양쪽에서 컬럼이 깔끔히 정렬되도록 구성
- 모바일에서도 모든 기능 사용 가능

### 테마 토글
- 헤더의 스위치로 라이트/다크 모드를 즉시 전환
- 선호 테마는 로컬 스토리지에 저장

---

## 실시간 데이터 파이프라인

1. **마켓 초기화** (`useMarketInitialization`)  
   업비트 `/v1/market/all`을 한 번 호출해 KRW 마켓만 필터링하고, `upbitCoins` 맵과 `coinNames` 배열, 기본 USDT 심볼셋을 Redux에 채워 넣습니다.

2. **초기 시세 로딩** (`useInitialPriceFetch`)  
   초기화된 마켓 코드를 콤마로 합쳐 업비트 `/v1/ticker`를 호출하고, `coinKrwPriceSlice`에 첫 화면을 그릴 수 있는 가격/하락률/거래대금 정보를 저장합니다.

3. **실시간 스트림** (`useRealtimePriceStreams`)  
   - 업비트 WebSocket: Blob을 `text()`로 파싱해 체결가, 전일 종가, 등락률을 받고 `syncKRWPrice2`로 Redux를 업데이트합니다.  
   - 바이낸스 선물 WebSocket: `fstream.binance.com`의 `@markPrice@1s` 스트림을 여러 코인으로 묶어 구독하고, `syncUSPRICE`로 해외 시세를 갱신합니다.  
   - 두 스트림 모두 `requestAnimationFrame` 안에서 배치 처리해 초당 수십 건의 dispatch가 발생해도 프레임이 끊기지 않습니다.

4. **환율 동기화** (`useExchangeRate`)  
   Google Spreadsheet CSV에서 KRW/USD를 읽어오고, 실패 시 1,389원을 즉시 대체 값으로 사용합니다. 헤더와 김치프리미엄 계산에서 동일한 환율을 공유합니다.

---

## 정렬/필터 규칙

- 즐겨찾기는 `coin_favorites` 쿠키에 저장되고 리스트의 맨 위에 항상 고정됩니다.
- 검색창은 한글/영문 이름을 모두 소문자로 변환해 부분 일치 검색을 수행합니다.
- 정렬 버튼을 누를 때마다 `오름차순 → 내림차순 → 기본`으로 순환하며, 기본 상태에서는 KRW 가격 내림차순으로 정렬됩니다.

| 정렬 키 | 설명 |
| --- | --- |
| `koreanName` | 한글 이름 기준 사전순 |
| `price` | 업비트 KRW 현재가 |
| `kimp` | `(국내가 - (해외 USDT × 환율)) / (해외 USDT × 환율)` 로 계산한 김치프리미엄 |
| `prevPrice` | 업비트 전일 종가 |
| `absValue` | 전일 대비 절대 변동 금액 (`change_price` 값을 등락 방향에 맞춰 부호 적용) |
| `changePercent` | 등락률 (`change_rate × 100` 값을 방향에 따라 ± 표시) |
| `accTradePrice24h` | 업비트 24시간 누적 거래대금 |

---

## 모의 투자 흐름

- `useMockTradingState`가 `mockTrading_balance`/`mockTrading_positions` 키를 로컬 스토리지에서 읽어 초기 잔고(1천만 원)와 포지션 배열을 구성하고, 변경 사항은 `storage` 및 커스텀 `mockTradingUpdate` 이벤트로 다른 탭과도 동기화됩니다.
- `MockTradingDashboard`의 `AssetSummary`는 `utils/mockTrading`의 집계 함수로 총자산·투자금·손익·수익률을 계산하고, 입금(`DepositModal`)과 전체 리셋(`ResetModal`)을 제공합니다.
- `PositionsTable`은 보유 포지션을 테이블로 보여주며, 한 행을 클릭하면 `MockTradingPanel` 바텀시트가 열려 해당 코인에 집중할 수 있습니다.
- 바텀시트에는 TradingView 차트, `PanelBalanceSummary`, `BuyTradeForm`, `SellTradeForm`, 잔여 수량/최대 매수 계산 등이 포함돼 있습니다.
- 매수 시 `applyBuyToPositions`가 `(기존 총액 + 신규 총액) / 총 수량` 방식으로 평균 단가를 재계산하고, 매도 시 `applySellToPositions`가 수량을 차감하며 `calculateSellProfit`으로 손익을 계산합니다. 모든 수량은 8자리까지 반올림해 거래합니다.
- 모든 변경 사항은 즉시 저장되므로 페이지를 새로고침해도 포지션과 잔고, 매수 날짜가 유지됩니다.

---

## 기술 스택

- **React 18 + TypeScript**: 타입 안정성과 컴포넌트 단위 개발
- **Vite**: 빠른 HMR과 번들링
- **Redux Toolkit + React Redux**: 실시간 가격/환율 상태 중앙 집중 관리
- **React Router DOM**: 라우팅 관리
- **Tailwind CSS**: 테이블·차트·패널을 유연하게 스타일링
- **Axios & WebSocket**: REST 호출과 실시간 시세 스트림
- **Socket.IO Client**: 실시간 채팅 기능
- **TradingView Widget**: 전문적인 차트 제공
- **React GA4**: 사용자 행동 분석
- **React Icons**: 아이콘 라이브러리
- **Vercel**: 배포 플랫폼 (API 프록시 설정 포함)

---

## 프로젝트 구조

```
src/
├── api/
│   ├── services/          # 환율·업비트 등 외부 API 호출
│   └── types/             # API 응답 타입 정의
├── components/
│   ├── chart/             # TradingView 차트 컴포넌트
│   ├── chat/              # 실시간 채팅 위젯 및 관련 컴포넌트
│   ├── coinTable/         # 시세 테이블과 셀 컴포넌트
│   ├── coinList/          # 검색/필터 등 리스트 UI
│   ├── mockTrading/       # 모의 투자 대시보드 & 패널
│   └── layout/            # 헤더·푸터 등 공용 레이아웃
├── hooks/
│   ├── coinList/          # 리스트 관련 상태 훅
│   └── mockTrading/       # 모의 투자 상태 훅
├── store/                 # Redux slice와 스토어 설정
├── styles/                # Tailwind 진입점(global.css)
├── types/                 # 도메인 전역 타입
├── utils/                 # 포매터, 계산 로직
└── pages/                 # 최상위 페이지
```

컴포넌트를 역할별로 쪼개면서 차트, 테이블, 모의 투자 UI, 채팅을 독립적으로 다룰 수 있어 유지보수가 쉬워졌습니다.

---

## 개발하면서 배운 점

### WebSocket 메시지 처리와 성능 최적화

업비트 WebSocket이 Blob 형식으로 데이터를 보내주는데, 처음엔 `FileReader`를 썼습니다. 그런데 코드가 복잡해지고, `Blob.text()`가 더 간단하다는 걸 나중에 알았습니다. 작은 것들이지만 이런 걸 알게 되는 게 재밌습니다.

진짜 문제는 메시지가 너무 빨리 와서 Redux dispatch가 과도하게 발생하는 거였습니다. 화면이 버벅거리기 시작했고, 개발자 도구를 보니 초당 수십 번씩 dispatch가 일어나고 있었습니다. 이걸 해결하려고 `requestAnimationFrame`으로 배치 처리하니 훨씬 부드러워졌습니다. 

실시간 데이터를 다룰 때는 이런 최적화가 정말 중요하다는 걸 느꼈습니다. 단순히 데이터를 받아서 상태에 넣는 게 아니라, 언제 어떻게 업데이트할지도 고민해야 합니다.

### React 성능 최적화의 중요성

가격이 업데이트될 때마다 전체 테이블이 리렌더링되면서 화면이 버벅거렸습니다. 처음엔 뭐가 문제인지도 모르겠고, 그냥 "React가 느린가?" 싶었습니다. 

`React.memo`로 컴포넌트를 감싸고, `useMemo`와 `useCallback`을 적절히 사용하니 확실히 나아졌습니다. Redux store 설정에서 `immutableCheck: false`로 설정하는 것도 도움이 됐습니다. 

이 과정에서 배운 건, 성능 문제는 보통 한 곳에 있는 게 아니라 여러 곳에서 조금씩 누적되는 거라는 겁니다. 하나씩 최적화해나가면서 점점 부드러워지는 걸 보는 게 뿌듯했습니다.

### 모바일 반응형의 어려움

모바일에서 테이블을 보여주는 게 생각보다 어려웠습니다. 처음엔 카드 형식으로 만들었는데, 사용자가 테이블 형식을 원해서 다시 바꿨습니다. 

폰트 크기를 줄이고, 패딩을 최소화하고, 컬럼 너비를 조정해도 가로 스크롤이 생겼습니다. `table-layout: fixed`를 쓰고 각 컬럼에 명시적으로 너비를 지정하니 해결됐습니다. 

모바일에서는 정말 픽셀 단위로 신경 써야 한다는 걸 느꼈습니다. 데스크톱에서는 문제없던 게 모바일에서는 완전히 깨졌었습니다. 미디어 쿼리로 하나하나 조정하는 게 번거로웠지만, 결과를 보니 그럴 만했습니다.

### Redux와 로컬 상태의 균형

Redux를 처음 써봤는데, 처음엔 모든 상태를 Redux에 넣으려고 했습니다. 검색어도, 정렬 설정도, 차트 열림 상태도 전부. 그런데 이게 오히려 복잡해졌습니다.

나중에 깨달은 건, 정말 전역으로 공유해야 하는 상태(가격 데이터, 코인 목록)만 Redux에 넣고, 나머지는 `useState`로 관리하는 게 훨씬 간단하다는 거였습니다. 

Redux Toolkit의 `createSlice`가 정말 편했습니다. 기존 Redux처럼 액션 타입, 액션 크리에이터, 리듀서를 각각 작성할 필요 없이 한 곳에서 정의할 수 있어서 코드가 훨씬 간결해졌습니다. `immer`가 내장되어 있어서 불변성 신경 안 써도 되는 것도 좋았습니다.

### TradingView 위젯 통합

기존에 직접 구현했던 SVG 캔들 차트를 TradingView 위젯으로 교체했습니다. 직접 구현한 차트보다 훨씬 전문적이고 기능이 많아서 사용자 경험이 크게 개선되었습니다.

TradingView 위젯을 통합하면서 심볼 매칭, 테마 동기화, 위젯 재생성 최적화 등 여러 고려사항이 있었습니다. 특히 바이낸스에 상장된 코인은 바이낸스 차트를, 그 외는 업비트 차트를 자동으로 표시하도록 구현한 것이 만족스러웠습니다.

### 실시간 채팅 구현

Socket.IO를 사용해서 실시간 채팅 기능을 추가했습니다. 처음에는 단순히 메시지를 주고받는 기능만 생각했는데, 사용자 수 표시, 새 메시지 알림, 닉네임 관리 등 생각보다 고려할 게 많았습니다.

특히 여러 탭에서 동시에 열려있을 때 메시지 동기화와 알림 처리가 까다로웠습니다. ref를 활용해서 최신 상태를 유지하면서도 불필요한 리렌더링을 방지하는 방법을 배웠습니다.

### TypeScript 타입 가드의 유용성

WebSocket 메시지 같은 동적 데이터를 다룰 때 타입 가드가 정말 유용했습니다. `if (parsed.data && parsed.data.s && parsed.data.p)` 같은 체크를 타입으로 보장할 수 있어서, 그 이후 코드에서는 안전하게 속성에 접근할 수 있었습니다.

처음엔 타입 정의하는 게 번거로웠지만, 나중에 API가 변경됐을 때 에디터에서 바로 에러를 잡아주니까 디버깅 시간이 확실히 줄었습니다. 런타임 에러보다 컴파일 타임 에러가 훨씬 찾기 쉽습니다.

### 컴포넌트 분리의 중요성

처음엔 큰 컴포넌트 하나에 모든 걸 때려넣었습니다. 그런데 나중에 수정하려고 보니 어디가 뭘 하는지 찾기 어려웠습니다. 

작은 컴포넌트로 분리하면서 재사용성과 가독성이 훨씬 좋아졌습니다. 특히 테이블 셀들을 각각 컴포넌트로 분리한 게 좋은 선택이었습니다. 나중에 스타일을 바꾸거나 기능을 추가할 때도 해당 컴포넌트만 수정하면 돼서 편했습니다.

### Tailwind로 테이블과 UI 정리하기

예전에는 Bootstrap 컴포넌트에 스타일을 덧대서 쓰다 보니 세부 간격이나 반응형 처리가 마음대로 되지 않았습니다. Tailwind로 갈아타고 나서는 클래스 하나하나 손으로 정리해야 해서 귀찮긴 했지만, 컬럼 폭이나 모바일 패딩을 픽셀 단위로 맞출 수 있어서 훨씬 깔끔해졌습니다.

### 모의 투자 패널을 만들며

실시간 시세만 보여주는 게 아쉬워서 모의 투자 탭을 붙였는데, 생각보다 고려할 게 많았습니다. 잔고 업데이트, 포지션 평균 단가 계산, 매수/매도 폼 유효성 검사까지 다 직접 만들어야 했습니다. 

특히 평균 단가 계산 로직을 구현할 때, 기존 포지션이 있을 때와 없을 때를 구분해서 처리해야 했습니다. 매수할 때마다 `(기존 총액 + 신규 총액) / 총 수량`으로 평균 단가를 다시 계산하는 로직을 직접 구현했습니다.

로컬 스토리지에 데이터를 저장해서 새로고침해도 포지션이 유지되도록 했고, 여러 탭에서 동기화되도록 `storage` 이벤트 리스너도 추가했습니다.

---

## 어려웠던 점

### 바이낸스 WebSocket 데이터 파싱

바이낸스는 스트림 형식으로 여러 코인을 한 번에 보내주는데, 데이터 구조가 복잡했습니다. `{ data: { s: "BTCUSDT", p: "50000" } }` 형식으로 파싱해야 했고, 특히 심볼을 `BTCUSDT` → `BTC`로 변환하고 대문자로 만드는 걸 깜빡해서 한참 디버깅했습니다. 가격이 업데이트가 안 되는 줄 알고 WebSocket 연결 문제인 줄 알았는데, 알고 보니 심볼 매칭이 안 돼서였습니다. 

이런 작은 실수 하나가 몇 시간을 날릴 수 있다는 걸 뼈저리게 느꼈습니다. 디버깅할 때는 항상 데이터를 콘솔에 찍어보는 게 중요합니다.

### 실시간 업데이트 성능 문제

가격이 업데이트될 때마다 애니메이션이 실행되면서 성능이 저하됐습니다. 처음엔 배경색 애니메이션을 썼는데, 이게 너무 무거웠습니다. 텍스트 색상 애니메이션으로 바꿨는데도 부드럽지 않았습니다.

`requestAnimationFrame`으로 배치 처리하니 훨씬 나아졌습니다. 하지만 여전히 완벽하지는 않습니다. 실시간으로 수십 개의 가격이 동시에 업데이트되면 어느 정도 버벅거림은 피할 수 없는 것 같습니다.

이 과정에서 배운 건, 애니메이션은 신중하게 써야 한다는 겁니다. 모든 걸 애니메이션으로 만들면 오히려 사용자 경험이 나빠질 수 있습니다.

### 모바일 레이아웃의 한계

모바일에서 테이블을 보여주면서도 가로 스크롤 없이 모든 정보를 보여주는 게 어려웠습니다. 폰트 크기를 줄이고, 패딩을 최소화하고, 컬럼 너비를 조정해도 여전히 공간이 부족했습니다.

결국 일부 컬럼을 숨기거나, 폰트 크기를 더 줄이거나, 레이아웃을 바꿔야 했습니다. 완벽한 해결책은 없었고, 타협점을 찾는 게 중요했습니다.

모바일에서는 정말 제약이 많다는 걸 느꼈습니다. 데스크톱에서는 당연하게 보여줄 수 있는 정보도 모바일에서는 포기해야 할 때가 있습니다.

### TradingView 위젯 최적화

TradingView 위젯을 통합하면서 심볼이 변경될 때마다 위젯을 재생성하는 문제가 있었습니다. 처음에는 심볼이 바뀔 때마다 위젯을 완전히 제거하고 다시 생성했는데, 이게 너무 느렸습니다.

나중에 심볼이나 테마가 실제로 변경되었을 때만 위젯을 재생성하도록 최적화했습니다. ref를 사용해서 이전 심볼과 테마를 추적하고, 변경되었을 때만 위젯을 재생성하도록 했습니다.

---

## 앞으로 개선하고 싶은 점

1. **차트 기능 강화** - TradingView 위젯의 다양한 기능 활용
2. **알림 기능** - 특정 김치프리미엄 수준에 도달하면 알림
3. **히스토리 데이터** - 과거 김치프리미엄 추이를 그래프로 표시
4. **다른 거래소 추가** - 바이낸스 말고 다른 거래소도 비교
5. **성능 최적화** - 가상화(virtualization) 적용해서 더 많은 코인 부드럽게 표시
6. **채팅 기능 개선** - 이모지 지원, 이미지 업로드 등

---

## 설치 및 실행

```bash
# 의존성 설치
npm install

# 개발 서버 실행 (포트 3000)
npm run dev

# 빌드
npm run build

# 빌드 결과 미리보기
npm run preview
```

### 개발 환경 설정

환경 변수는 `.env` 파일에 설정하면 됩니다 (선택사항):
```
VITE_GA_PROPERTYID=your_ga_id
```

> 참고: 환경 변수가 없어도 앱은 정상 작동하지만, Google Analytics 추적 기능만 비활성화됩니다.

### Vite 프록시 설정

개발 환경에서 업비트 API를 사용하기 위해 `vite.config.ts`에 프록시 설정이 포함되어 있습니다:
- `/api/*` → `https://api.upbit.com/*`
- `/wss/*` → `wss://api.upbit.com/*` (WebSocket)

프로덕션 환경에서는 Vercel의 `vercel.json` 설정을 통해 API 프록시가 처리됩니다.

### 채팅 서버

채팅 기능은 별도의 Socket.IO 서버가 필요합니다. 현재는 클라이언트에서 `io()`로 연결하도록 되어 있으며, 서버 URL은 환경 변수로 설정할 수 있습니다.

---

## 데이터 출처 & 저장 방식

### 외부 데이터 소스

- **업비트 REST API**: `/v1/market/all`, `/v1/ticker`를 Vite/Vercel 프록시로 호출해 마켓·현재가 데이터를 가져옵니다.
- **업비트 WebSocket**: `wss://api.upbit.com/websocket/v1`의 `ticker` 스트림으로 실시간 체결가, 등락률, 24시간 거래대금을 수신합니다.
- **바이낸스 Futures WebSocket**: `wss://fstream.binance.com/stream?streams={symbol}@markPrice@1s`로 해외 USDT 기준가를 가져옵니다.
- **TradingView**: TradingView 위젯을 통해 차트 데이터를 제공합니다.
- **환율 데이터**: Google Spreadsheet CSV를 직접 읽어오고(실패 시 1,389원으로 폴백), 헤더와 김치프리미엄 계산에 재사용합니다.

### 클라이언트 저장

- **즐겨찾기**: 쿠키에 저장 (1년 만료, `coin_favorites` 키 사용)
- **모의 투자 데이터**: 로컬 스토리지에 저장
  - 잔고: `mockTrading_balance` 키
  - 포지션: `mockTrading_positions` 키 (JSON 형식)
  - 기본 잔고: 10,000,000원
  - 여러 탭 간 동기화 지원 (`storage` + 커스텀 `mockTradingUpdate` 이벤트)
- **채팅 닉네임**: 로컬 스토리지에 저장 (`chat-username` 키)
- **테마 설정**: 로컬 스토리지에 저장

## 배포

- **플랫폼**: Vercel
- **API 프록시**: `vercel.json`을 통해 업비트 API 프록시 설정
- **빌드**: Vite 빌드 결과물을 Vercel에 배포
- **환경 변수**: Vercel 대시보드에서 `VITE_GA_PROPERTYID` 설정

## 후기

처음엔 단순히 가격만 보여주면 될 줄 알았는데, 막상 만들다 보니 생각보다 많은 기능이 필요했습니다. WebSocket을 다루고, 성능 최적화를 하고, 모바일 반응형을 구현하면서 실무에 가까운 경험을 할 수 있었습니다.

특히 모의 투자 기능을 추가하면서 단순히 데이터를 보여주는 것을 넘어서 사용자가 직접 상호작용할 수 있는 기능을 만드는 게 얼마나 복잡한지 알게 됐습니다. 평균 단가 계산, 손익 추적 등 하나하나 구현하면서 많은 걸 배웠습니다.

TradingView로 차트를 교체하고 채팅 기능을 추가하면서, 사용자 경험을 개선하는 것의 중요성도 느꼈습니다. 단순히 기능을 추가하는 것이 아니라, 사용자가 실제로 편하게 사용할 수 있도록 고민하는 것이 중요하다는 걸 배웠습니다.

아직 부족한 점이 많지만, 계속 개선해나가면서 더 나은 서비스로 만들어가고 싶습니다.

## 느낀 점

개발 초반에는 "이 정도면 됐겠지" 싶다가도 직접 써보면 항상 아쉬운 부분이 튀어나왔습니다. 차트 패딩이 어색하면 그 작은 디테일 때문에 전체 완성도가 떨어져 보이고, 테이블이 살짝만 어긋나도 신뢰도가 확 줄어들었습니다. 그래서 결국은 디테일을 다듬는 시간이 프로젝트의 절반 이상이라는 걸 몸소 느꼈습니다. 

그래도 그런 시행착오 덕분에 내가 원하는 퀄리티가 어떤 건지 조금씩 감이 잡히는 것 같습니다. 그리고 사용자 피드백을 받으면서 "이 기능이 정말 필요한가?"를 계속 되묻게 되었습니다. 불필요한 기능을 추가하는 것보다, 핵심 기능을 잘 만드는 게 더 중요하다는 걸 배웠습니다.
